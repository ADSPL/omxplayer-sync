#!/usr/bin/env python
#
# omxplayer-sync
#
# Copyright 2012, Simon Josi
# Simon Josi me(at)yokto(dot)net
#
# This program is free software; you can redistribute 
# it and/or modify it under the terms of the GNU 
# General Public License version 3 as published by 
# the Free Software Foundation.
#

import re
import os
import sys
import math
import dbus
import socket
import thread
import pexpect
import signal
import collections
from time import sleep, time
from threading import local
from optparse import OptionParser, BadOptionError, AmbiguousOptionError

OMXPLAYER = 'omxplayer'
PORT = 1666
TOLERANCE = 0.1
SYNC_WINDOW = (-0.3, -0.2)

OMXPLAYER_REGEX_STATUS = re.compile(r"M:\s*(\d+) ")
OMXPLAYER_REGEX_DONE = re.compile(r"have a nice day.*")
OMXPLAYER_DBUS_ADDR='/tmp/omxplayerdbus'

global position_master
position_master = 0.0

global filename_master
filename_master = ''

class PassThroughOptionParser(OptionParser):
    """
    An unknown option pass-through implementation of OptionParser.

    When unknown arguments are encountered, bundle with largs and try again,
    until rargs is depleted.  

    sys.exit(status) will still be called if a known argument is passed
    incorrectly (e.g. missing arguments or bad argument types, etc.)        
    """
    def _process_args(self, largs, rargs, values):
        while rargs:
            try:
                OptionParser._process_args(self,largs,rargs,values)
            except (BadOptionError,AmbiguousOptionError), e:
                largs.append(e.opt_str)

def read_position_master():
   global position_master
   global filename_master

   sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
   sock.bind(('0.0.0.0', PORT))

   while True:
       data = sock.recvfrom(1024)[0].split('%', 1)
       position_master = float(data[0])
       filename_master = data[1]

def play_file(filename, options, omxplayer_options):
    if options.master:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

        try:
            sock.connect((options.destination, PORT))
        except:
            if options.verbose:
                 print "connect: Network is unreachable"
            pass

    process = pexpect.spawn('%s -s %s %s' % (
        OMXPLAYER, ' '.join(omxplayer_options), filename), timeout=0.01)
    position_local = 0.0
    sync_enabled=True

    if options.verbose:
        print "playing %s" % filename

    def kill_process(signum, frame):
         try:
             os.kill(-process.pid, 15)
         except:
             pass
         try:
             process.kill(15)
         except:
             pass
         sys.exit(0)
    signal.signal(signal.SIGINT, kill_process)

    if options.slave:
        wait_for_sync = False
        wait_after_sync = True
        deviations = collections.deque(maxlen=25)

        # get dbus player interface
        sleep(1) # wait for omxplayer to appear on dbus
        try:
            bus = dbus.bus.BusConnection(open(OMXPLAYER_DBUS_ADDR).readlines()[0].rstrip())
            proxy = bus.get_object('org.mpris.MediaPlayer2.omxplayer', '/org/mpris/MediaPlayer2', introspect=False)
            player_interface = dbus.Interface(proxy, 'org.mpris.MediaPlayer2.Player')
        except:
            print "WARNING: dbus connection could not be established, syncing is disabled"
            sleep(5)
            sync_enabled=False

    while True:
        eof = False
        while True:
            index = process.expect([
                OMXPLAYER_REGEX_STATUS,
                pexpect.TIMEOUT,
                pexpect.EOF,
                OMXPLAYER_REGEX_DONE,
            ])
            if index == 1:
                break
            elif index in (2,3):
                if options.verbose:
                    print "omxplayer has ended..."
                eof = True
                break
            else:
                position_local = (float(process.match.group(1)) / 1000000)
        if eof: break


        if options.master:
            if options.verbose:
                sys.stdout.write("local: %.2f %.0f\n" % (position_local, math.modf(position_local)[0]*100/4))

            try:
                sock.send('%s%%%s' % (str(position_local), filename))
            except socket.error:
                pass

        if options.slave and sync_enabled:
            deviation = position_master - position_local
            deviations.append(deviation)
            moving_deviation = sum(list(deviations)) / float(len(list(deviations)))

            if options.verbose:
                print "local: %.2f master: %.2f deviation: %.2f moving_deviation: %.2f filename: %s filename_master: %s wait: %r" % (
                    position_local, position_master, deviation, moving_deviation, filename, filename_master, wait_for_sync)

            if wait_for_sync:
                if moving_deviation >= SYNC_WINDOW[0] and moving_deviation < SYNC_WINDOW[1]:
                    if options.verbose:
                        print "we are sync, play..."
                    player_interface.Action(16)
                    wait_for_sync = False
                    wait_after_sync = time()
 
                continue

            if wait_after_sync:
                if (time() - wait_after_sync) > 5:
                     wait_after_sync = False

                continue

            if abs(moving_deviation) > TOLERANCE \
            and position_local > 1.0 \
            and position_master > 1.0 \
            and filename == filename_master:
                if options.verbose:
                    print "jump to %.2f" % position_master
                player_interface.SetPosition(dbus.ObjectPath('/not/used'), long((position_master + 5) * 1000000))
                player_interface.Action(16)
                wait_for_sync = True

    try:
        os.kill(-process.pid, 15)
    except:
        pass
    try:
        process.kill(15)
    except:
        pass

def main():
    p = PassThroughOptionParser()
    p.add_option('--master', '-m', action='store_true')
    p.add_option('--slave', '-l', action='store_true')
    p.add_option('--destination', '-x', default='255.255.255.255')
    p.add_option('--loop', '-u', action='store_true')
    p.add_option('--verbose', '-v', action='store_true')
    options, arguments = p.parse_args()

    filenames, omxplayer_options = [], []
    for argument in arguments:
        if argument.startswith('-'):
            omxplayer_options.append(argument)
        else:
            filenames.append(argument)

    if options.slave:
        thread.start_new_thread(read_position_master,())
        sleep(0.1)

    while True:
        for filename in filenames:
            play_file(filename, options, omxplayer_options)

        if not options.loop: break

if __name__ == '__main__':
    main()
