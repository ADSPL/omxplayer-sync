#!/usr/bin/env python
#
# omxplayer-sync
#
# Copyright 2012, Simon Josi
# Simon Josi me(at)yokto(dot)net
#
# This program is free software; you can redistribute 
# it and/or modify it under the terms of the GNU 
# General Public License version 3 as published by 
# the Free Software Foundation.
#

import re
import os
import sys
import math
import socket
import thread
import pexpect
import signal
import collections
from time import sleep, time
from threading import local
from optparse import OptionParser, BadOptionError, AmbiguousOptionError

OMXPLAYER = 'omxplayer'
PORT = 1666
TOLERANCE = 0.3
SEEK_SIZE = 2

REGEX_STATUS = re.compile(r"M:\s*(\d+) ")
REGEX_DONE = re.compile(r"have a nice day.*")

SLEEP_INIT_SLAVE = 0.1
SLEEP_INIT_MASTER = 0.2
SYNC_WINDOW = (-0.4, -0.3)

global position_master
position_master = 0.0

global filename_master
filename_master = ''

class PassThroughOptionParser(OptionParser):
    """
    An unknown option pass-through implementation of OptionParser.

    When unknown arguments are encountered, bundle with largs and try again,
    until rargs is depleted.  

    sys.exit(status) will still be called if a known argument is passed
    incorrectly (e.g. missing arguments or bad argument types, etc.)        
    """
    def _process_args(self, largs, rargs, values):
        while rargs:
            try:
                OptionParser._process_args(self,largs,rargs,values)
            except (BadOptionError,AmbiguousOptionError), e:
                largs.append(e.opt_str)

def read_position_master():
   global position_master
   global filename_master

   sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
   sock.bind(('0.0.0.0', PORT))

   while True:
       data = sock.recvfrom(1024)[0].split('%', 1)
       position_master = float(data[0])
       filename_master = data[1]

def play_file(filename, options, omxplayer_options):
    if options.master:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

        try:
            sock.connect((options.destination, PORT))
        except:
            if options.verbose:
                 print "connect: Network is unreachable"
            pass

        try:
            sock.send('%s%%%s' % (str(0.0), filename))
        except socket.error:
           pass

        sleep(SLEEP_INIT_MASTER)

    process = pexpect.spawn('%s -s %s %s' % (
        OMXPLAYER, ' '.join(omxplayer_options), filename), timeout=0.01)
    position_local = 0.0
    position_local_queue = collections.deque(maxlen=25)
    position_local_queue.append(0)

    if options.verbose:
        print "playing %s" % filename

    def kill_process(signum, frame):
         try:
             os.kill(-process.pid, 15)
         except:
             pass
         try:
             process.kill(15)
         except:
             pass
         sys.exit(0)
    signal.signal(signal.SIGINT, kill_process)

    if options.slave:
        wait_for_sync = False
        wait_after_sync = True
        deviations = collections.deque(maxlen=25)

    while True:
        eof = False
        while True:
            index = process.expect([
                REGEX_STATUS,
                pexpect.TIMEOUT,
                pexpect.EOF,
                REGEX_DONE,
            ])
            if index == 1:
                break
            elif index in (2,3):
                if options.verbose:
                    print "omxplayer has ended..."
                eof = True
                break
            else:
                position_local = (float(process.match.group(1)) / 1000000)
                position_local_queue.append(position_local)
        if eof: break


        if options.master:
            if options.verbose:
                sys.stdout.write("local: %.2f %.0f\n" % (position_local, math.modf(position_local)[0]*100/4))
                sys.stdout.write("queue0: %.2f queue1: %.2f\n" % (position_local_queue[0], position_local_queue[-1]))

            if position_local > 5.0 \
            and position_master > 5.0 \
            and len(position_local_queue) == 25 \
            and position_local_queue[0] == position_local_queue[-1]:
                if options.verbose:
                    print "detected local time stall, killing omxplayer instance..."
                kill_process(None, None)

            try:
                sock.send('%s%%%s' % (str(position_local), filename))
            except socket.error:
                pass

        if options.slave:
            deviation = position_master - position_local
            deviations.append(deviation)
            moving_deviation = sum(list(deviations)) / float(len(list(deviations)))

            if options.verbose:
                print "local: %.2f master: %.2f deviation: %.2f moving_deviation: %.2f wait: %r" % (
                    position_local, position_master, deviation, moving_deviation, wait_for_sync)
                sys.stdout.write("queue0: %.2f queue1: %.2f\n" % (position_local_queue[0], position_local_queue[-1]))

            if not wait_for_sync:
                if position_local > 5.0 \
                and position_master > 5.0 \
                and len(position_local_queue) == 25 \
                and position_local_queue[0] == position_local_queue[-1]:
                    if options.verbose:
                         print "detected local time stall, killing omxplayer instance..."
                    kill_process(None, None)

            if wait_for_sync:
                if moving_deviation >= SYNC_WINDOW[0] and moving_deviation < SYNC_WINDOW[1]:
                    process.send('p')
                    if options.verbose:
                        print "we are sync, play..."
                    position_local_queue.clear()
                    position_local_queue.append(0)
                    wait_for_sync = False
                    wait_after_sync = time()

                continue
            
            if wait_after_sync:
                if (time() - wait_after_sync) > 5:
                     wait_after_sync = False

                continue

            if abs(moving_deviation) > TOLERANCE \
            and position_local > 1.0 \
            and position_master > 1.0 \
            and filename == filename_master:
                sleep(0.2)
                if position_local < position_master :
                    if options.verbose:
                        print "seek forward..."
                    process.send('\x1B[C')
                elif position_local > (position_master + 15 + SEEK_SIZE):
                    if options.verbose:
                        print "seek backwards..."
		    sleep(1)
                    process.send('\x1B[D')
                else:
                    process.send('p')
                    if options.verbose:
                        print "enter wait..."
                    wait_for_sync=True
                sleep(0.2)

    try:
        os.kill(-process.pid, 15)
    except:
        pass
    try:
        process.kill(15)
    except:
        pass

def main():
    p = PassThroughOptionParser()
    p.add_option('--master', '-m', action='store_true')
    p.add_option('--slave', '-l', action='store_true')
    p.add_option('--destination', '-x', default='255.255.255.255')
    p.add_option('--loop', '-u', action='store_true')
    p.add_option('--verbose', '-v', action='store_true')
    options, arguments = p.parse_args()

    filenames, omxplayer_options = [], []
    for argument in arguments:
        if argument.startswith('-'):
            omxplayer_options.append(argument)
        else:
            filenames.append(argument)

    if options.slave:
        thread.start_new_thread(read_position_master,())
        sleep(0.1)

    while True:
        for filename in filenames:
            if options.slave:
                sleep(SLEEP_INIT_SLAVE)
                if filename_master in filenames:
                    filename = filename_master

            play_file(filename, options, omxplayer_options)

        if not options.loop: break

if __name__ == '__main__':
    main()
